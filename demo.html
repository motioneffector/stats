<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/stats - Interactive Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
      line-height: 1.6;
    }
    h1 { color: #2c3e50; margin-bottom: 0.25em; }
    h2 { color: #34495e; border-bottom: 2px solid #3498db; padding-bottom: 0.5em; margin-top: 2em; }
    section {
      margin: 20px 0;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .subtitle { color: #7f8c8d; margin-top: 0; }
    .test-pass { color: #27ae60; font-weight: 500; }
    .test-fail { color: #e74c3c; font-weight: bold; }
    .test-output {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 500px;
      overflow-y: auto;
      border-radius: 4px;
      line-height: 1.4;
    }
    .test-output div { margin: 2px 0; }
    button {
      padding: 10px 20px;
      margin: 4px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    button:active { transform: translateY(0); }
    .run-all {
      background: #27ae60;
      color: white;
      font-size: 16px;
      padding: 12px 32px;
    }
    .run-all:hover { background: #229954; }
    .clear-btn { background: #95a5a6; color: white; }
    .clear-btn:hover { background: #7f8c8d; }
    .summary {
      font-size: 20px;
      font-weight: bold;
      margin: 15px 0;
      padding: 15px;
      border-radius: 4px;
      background: #ecf0f1;
    }
    .interactive-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 15px 0;
    }
    input, select {
      padding: 8px 12px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      font-size: 14px;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }
    .output-box {
      background: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      margin-top: 10px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      min-height: 60px;
    }
    .demo-btn { background: #3498db; color: white; }
    .demo-btn:hover { background: #2980b9; }
    label { font-weight: 500; margin-right: 8px; }
    code {
      background: #ecf0f1;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
    }
    .info { background: #d1ecf1; padding: 10px; border-radius: 4px; margin: 10px 0; border-left: 4px solid #0c5460; }
  </style>
</head>
<body>
  <h1>@motioneffector/stats</h1>
  <p class="subtitle">RPG stat management library - Interactive Demo & Test Suite</p>

  <section id="test-runner">
    <h2>üß™ Automated Test Suite</h2>
    <p>Comprehensive tests covering all library features. Click to verify everything works correctly.</p>
    <div style="margin: 15px 0;">
      <button class="run-all" onclick="runAllTests()">‚ñ∂ Run All Tests</button>
      <button class="clear-btn" onclick="clearResults()">Clear Results</button>
    </div>
    <div class="summary" id="summary"></div>
    <div class="test-output" id="test-output"></div>
  </section>

  <section>
    <h2>üé≤ Interactive: Dice Rolling</h2>
    <p>Try different dice notation formats. Supports basic rolls, modifiers, keep/drop, exploding, and reroll.</p>
    <div class="interactive-controls">
      <label>Notation:</label>
      <input type="text" id="diceNotation" value="2d6+3" placeholder="e.g., 2d6+3, 4d6kh3">
      <button class="demo-btn" onclick="rollDice()">Roll</button>
      <button class="demo-btn" onclick="setExample('1d20')">1d20</button>
      <button class="demo-btn" onclick="setExample('4d6kh3')">4d6kh3</button>
      <button class="demo-btn" onclick="setExample('1d6!')">Exploding</button>
    </div>
    <div class="output-box" id="diceOutput">Results will appear here...</div>
  </section>

  <section>
    <h2>üìä Interactive: Stat Block</h2>
    <p>Create a character stat block and modify it. Watch the events fire!</p>
    <div class="interactive-controls">
      <button class="demo-btn" onclick="createCharacter()">Create Character</button>
      <label>Set Strength:</label>
      <input type="number" id="strValue" value="16" min="1" max="20">
      <button class="demo-btn" onclick="setStat()">Set</button>
      <button class="demo-btn" onclick="addBuff()">Add +2 Buff</button>
      <button class="demo-btn" onclick="removeBuff()">Remove Buff</button>
    </div>
    <div class="output-box" id="statOutput">Create a character to begin...</div>
  </section>

  <section>
    <h2>‚öîÔ∏è Interactive: Stat Check</h2>
    <p>Perform stat checks with advantage/disadvantage mechanics (D&D 5e style).</p>
    <div class="interactive-controls">
      <label>Stat:</label>
      <select id="checkStat">
        <option>strength</option>
        <option>dexterity</option>
        <option>constitution</option>
      </select>
      <label>DC:</label>
      <input type="number" id="checkDC" value="15" min="1" max="30">
      <label>Mode:</label>
      <select id="checkMode">
        <option value="normal">Normal</option>
        <option value="advantage">Advantage</option>
        <option value="disadvantage">Disadvantage</option>
      </select>
      <button class="demo-btn" onclick="performCheck()">Check</button>
    </div>
    <div class="output-box" id="checkOutput">Perform a check to see results...</div>
  </section>

  <section>
    <h2>üéØ Interactive: Derived Stats</h2>
    <p>Create computed stats that automatically update when dependencies change.</p>
    <div class="interactive-controls">
      <button class="demo-btn" onclick="createDerivedDemo()">Create Derived Stat</button>
      <label>Update Strength:</label>
      <input type="number" id="derivedStr" value="16" min="1" max="20">
      <button class="demo-btn" onclick="updateDerived()">Update</button>
    </div>
    <div class="output-box" id="derivedOutput">Create a derived stat to begin...</div>
  </section>

  <!-- ============================================ -->
  <!-- INLINED LIBRARY CODE (from dist/index.js)    -->
  <!-- ============================================ -->
  <script>
    // Minified library code from dist/index.js
    class R extends Error {
      constructor(s) {
        super(s), this.name = "StatsError", Object.setPrototypeOf(this, new.target.prototype);
      }
    }
    class V extends R {
      constructor(s, t) {
        super(s), this.notation = t, this.name = "ParseError";
      }
    }
    class k extends R {
      constructor(s, t) {
        super(s), this.field = t, this.name = "ValidationError";
      }
    }
    class _ extends R {
      constructor(s, t) {
        super(s), this.cycle = t, this.name = "CircularDependencyError";
      }
    }
    class Y extends R {
      constructor(s, t) {
        super(s), this.version = t, this.name = "VersionError";
      }
    }
    const Z = 100;
    function N(o) {
      const s = o.trim();
      if (!s)
        throw new V("Dice notation cannot be empty", o);
      const t = s.replace(/\s+/g, "");
      if (t.match(/^-\d+[dD]/i))
        throw new V("Cannot roll negative number of dice", o);
      if (t.match(/[dD]-\d+/i))
        throw new V("Die cannot have negative sides", o);
      const h = /^(\d*)([dD])(\d+)/i, f = t.match(h);
      if (!f)
        throw new V(`Invalid dice notation: "${o}"`, o);
      const w = f[1], d = f[3];
      if (w.includes("."))
        throw new V("Dice count must be an integer", o);
      if (d.includes("."))
        throw new V("Die size must be an integer", o);
      const p = w === "" ? 1 : parseInt(w, 10), m = parseInt(d, 10);
      if (p === 0)
        throw new V("Cannot roll zero dice", o);
      if (p < 0)
        throw new V("Cannot roll negative number of dice", o);
      if (m === 0)
        throw new V("Die must have at least 1 side", o);
      if (m < 0)
        throw new V("Die cannot have negative sides", o);
      const i = t.slice(f[0].length), u = {
        count: p,
        sides: m,
        modifiers: 0,
        exploding: !1,
        rerollConditions: []
      };
      let l = 0;
      for (; l < i.length; ) {
        const a = i[l];
        if (a === "+" || a === "-") {
          const v = a === "+" ? 1 : -1;
          if (l++, l < i.length && (i[l] === "+" || i[l] === "-"))
            throw new V("Invalid modifier syntax", o);
          const x = i.slice(l).match(/^(\d+)/);
          if (!x)
            throw new V("Incomplete modifier", o);
          const M = x[1];
          if (M.includes("."))
            throw new V("Modifiers must be integers", o);
          u.modifiers += v * parseInt(M, 10), l += M.length;
          continue;
        }
        if (i.slice(l).match(/^[kK][hH]/i)) {
          l += 2;
          const v = i.slice(l).match(/^(\d+)/);
          v && (u.keepHighest = parseInt(v[1], 10), l += v[1].length);
          continue;
        }
        if (i.slice(l).match(/^[kK][lL]/i)) {
          l += 2;
          const v = i.slice(l).match(/^(\d+)/);
          v && (u.keepLowest = parseInt(v[1], 10), l += v[1].length);
          continue;
        }
        if (i.slice(l).match(/^[dD][hH]/i)) {
          l += 2;
          const v = i.slice(l).match(/^(\d+)/);
          v && (u.dropHighest = parseInt(v[1], 10), l += v[1].length);
          continue;
        }
        if (i.slice(l).match(/^[dD][lL]/i)) {
          l += 2;
          const v = i.slice(l).match(/^(\d+)/);
          v && (u.dropLowest = parseInt(v[1], 10), l += v[1].length);
          continue;
        }
        if (a === "!") {
          u.exploding = !0, l++;
          continue;
        }
        if (a === "r" || a === "R") {
          l++;
          const v = i.slice(l).match(/^(<=|>=|<|>|=)?(\d+)/);
          if (v) {
            const x = v[1] || "=", M = parseInt(v[2], 10);
            u.rerollConditions.push({ operator: x, value: M }), l += v[0].length;
          } else
            u.rerollConditions.push({ operator: "=", value: 1 });
          continue;
        }
        throw new V(`Unexpected character: "${a}"`, o);
      }
      return u;
    }
    function F(o) {
      return Math.floor(Math.random() * o) + 1;
    }
    function ee(o, s) {
      for (const t of s)
        switch (t.operator) {
          case "=":
            if (o === t.value) return !0;
            break;
          case "<":
            if (o < t.value) return !0;
            break;
          case ">":
            if (o > t.value) return !0;
            break;
          case "<=":
            if (o <= t.value) return !0;
            break;
          case ">=":
            if (o >= t.value) return !0;
            break;
        }
      return !1;
    }
    function te(o, s, t) {
      const h = [];
      let f = F(o), w = 1;
      for (h.push({ value: f, exploded: !1, rerolled: !1 }); s && f === o && w < Z; )
        f = F(o), h.push({ value: f, exploded: !0, rerolled: !1 }), w++;
      if (t.length > 0) {
        const d = h.length - 1, p = h[d];
        if (ee(p.value, t)) {
          const m = p.value, i = p.exploded, u = F(o);
          h[d] = { value: m, exploded: i, rerolled: !0 }, h.push({ value: u, exploded: !1, rerolled: !1 });
        }
      }
      return h;
    }
    function ne(o, s, t, h, f) {
      if (o.length === 0)
        return [];
      const w = [...o].sort((p, m) => p - m);
      let d = o.length;
      return s !== void 0 && (d = Math.min(d, s)), t !== void 0 && (d = Math.min(d, t)), h !== void 0 && (d = Math.min(d, o.length - h)), f !== void 0 && (d = Math.min(d, o.length - f)), d = Math.max(0, d), d === 0 ? [] : s !== void 0 || f !== void 0 ? w.slice(-d).sort((p, m) => p - m) : t !== void 0 || h !== void 0 ? w.slice(0, d) : w;
    }
    function S(o, s) {
      const t = N(o), h = [];
      for (let i = 0; i < t.count; i++)
        h.push(
          te(t.sides, t.exploding, t.rerollConditions)
        );
      const f = [], w = [];
      for (const i of h) {
        for (const a of i)
          w.push(a.value);
        let u = 0, l = -1;
        for (let a = 0; a < i.length; a++)
          if (i[a].rerolled) {
            l = a;
            break;
          }
        if (l >= 0) {
          for (let a = 0; a < l; a++)
            u += i[a].value;
          l + 1 < i.length && (u += i[l + 1].value);
        } else
          u = i.reduce((a, v) => a + v.value, 0);
        f.push(u);
      }
      const d = ne(
        f,
        t.keepHighest,
        t.keepLowest,
        t.dropHighest,
        t.dropLowest
      );
      return {
        total: d.reduce((i, u) => i + u, 0) + t.modifiers,
        rolls: w,
        kept: d,
        notation: o,
        modifier: t.modifiers
      };
    }
    function re(o, s) {
      const t = /* @__PURE__ */ new Map(), h = [], f = [], w = /* @__PURE__ */ new Map(), d = (s == null ? void 0 : s.historyLimit) ?? 100, p = s == null ? void 0 : s.modifierFormula;
      for (const [n, e] of Object.entries(o)) {
        if (e.min !== void 0 && e.max !== void 0 && e.min > e.max)
          throw new k(`Min (${e.min}) cannot be greater than max (${e.max})`, n);
        let r = e.base;
        e.min !== void 0 && (r = Math.max(r, e.min)), e.max !== void 0 && (r = Math.min(r, e.max));
        const c = {
          base: r,
          modifiers: [],
          isDerived: !1
        };
        e.min !== void 0 && (c.min = e.min), e.max !== void 0 && (c.max = e.max), t.set(n, c);
      }
      if (s != null && s.fromJSON) {
        const n = s.fromJSON, e = n.version ?? 1;
        if (e !== 1)
          throw new Y(`Unsupported version: ${e}`, e);
        for (const [r, c] of Object.entries(n.stats))
          if (t.has(r)) {
            const g = t.get(r);
            g.base = m(c, g.min, g.max);
          } else
            console.warn(`Unknown stat in JSON: ${r}`);
        for (const [r, c] of Object.entries(n.modifiers))
          if (t.has(r))
            for (const g of c)
              O(r, g);
          else
            console.warn(`Unknown stat in JSON modifiers: ${r}`);
      }
      function m(n, e, r) {
        let c = n;
        return e !== void 0 && (c = Math.max(c, e)), r !== void 0 && (c = Math.min(c, r)), c;
      }
      function i(n) {
        const e = t.get(n);
        if (!e) return 0;
        if (e.isDerived && e.derivedFormula)
          try {
            return e.derivedFormula(T);
          } catch (y) {
            return console.error(`Error calculating derived stat "${n}":`, y), 0;
          }
        let r = e.base;
        const c = e.modifiers.filter((y) => y.type === "flat");
        for (const y of c)
          r += y.value;
        const g = e.modifiers.filter((y) => y.type === "multiply");
        for (const y of g)
          r *= y.value;
        return r;
      }
      function u(n, e, r, c, g) {
        const y = {
          stat: n,
          oldValue: e,
          newValue: r,
          baseChanged: c,
          modifiersChanged: g
        };
        for (const b of f)
          try {
            b(y);
          } catch (E) {
            console.error("onChange callback error:", E);
          }
        const D = w.get(n);
        if (D)
          for (const b of D)
            try {
              b(y);
            } catch (E) {
              console.error("onStat callback error:", E);
            }
      }
      function l() {
        const n = /* @__PURE__ */ new Map();
        for (const [e, r] of t.entries())
          r.isDerived && n.set(e, i(e));
        return n;
      }
      function a(n) {
        for (const [e, r] of n.entries()) {
          const c = i(e);
          r !== c && u(e, r, c, !1, !1);
        }
      }
      function v(n) {
        if (t.has(n))
          return i(n);
      }
      function x(n) {
        const e = t.get(n);
        return e == null ? void 0 : e.base;
      }
      function M(n, e) {
        const r = t.get(n);
        if (!r)
          throw new TypeError(`Cannot set non-existent stat: "${n}"`);
        if (r.isDerived)
          throw new TypeError(`Cannot set derived stat "${n}"`);
        const c = i(n), g = l();
        r.base = m(e, r.min, r.max);
        const y = i(n);
        return c !== y && (u(n, c, y, !0, !1), a(g)), r.base;
      }
      function C(n, e) {
        const r = t.get(n);
        if (!r)
          throw new TypeError(`Cannot modify non-existent stat: "${n}"`);
        if (r.isDerived)
          throw new TypeError(`Cannot modify derived stat "${n}"`);
        const c = i(n), g = l();
        r.base = m(r.base + e, r.min, r.max);
        const y = i(n);
        return c !== y && (u(n, c, y, !0, !1), a(g)), r.base;
      }
      function I(n) {
        return t.has(n);
      }
      function $() {
        return Array.from(t.keys());
      }
      function O(n, e) {
        const r = t.get(n);
        if (!r)
          throw new TypeError(`Cannot add modifier to non-existent stat: "${n}"`);
        if (r.isDerived)
          throw new TypeError(`Cannot add modifier to derived stat "${n}"`);
        const c = i(n), g = l(), y = r.modifiers.findIndex((Q) => Q.source === e.source), D = e.type ?? "flat";
        let b = "permanent", E = 1 / 0;
        e.duration !== void 0 && (e.duration === "permanent" ? (b = "permanent", E = 1 / 0) : e.duration === "temporary" ? (b = 1, E = 1) : (b = e.duration, E = e.duration));
        const A = {
          value: e.value,
          source: e.source,
          type: D,
          duration: b,
          remainingDuration: E
        };
        y >= 0 ? r.modifiers[y] = A : r.modifiers.push(A);
        const L = i(n);
        return c !== L && (u(n, c, L, !1, !0), a(g)), {
          value: e.value,
          source: e.source,
          type: D,
          duration: e.duration ?? "permanent"
        };
      }
      function P(n, e) {
        const r = t.get(n);
        if (!r) return !1;
        const c = i(n), g = l(), y = r.modifiers.length;
        r.modifiers = r.modifiers.filter((b) => b.source !== e);
        const D = r.modifiers.length < y;
        if (D) {
          const b = i(n);
          c !== b && (u(n, c, b, !1, !0), a(g));
        }
        return D;
      }
      function j(n) {
        const e = t.get(n);
        if (e)
          return e.modifiers.map((r) => ({
            value: r.value,
            source: r.source,
            type: r.type,
            duration: r.remainingDuration === 1 / 0 ? "permanent" : r.remainingDuration
          }));
      }
      function H(n) {
        let e = 0;
        if (n !== void 0) {
          const r = t.get(n);
          if (r) {
            const c = i(n), g = l();
            e = r.modifiers.length, r.modifiers = [];
            const y = i(n);
            c !== y && e > 0 && (u(n, c, y, !1, !0), a(g));
          }
        } else {
          const r = l();
          for (const [c, g] of t.entries()) {
            const y = i(c), D = g.modifiers.length;
            g.modifiers = [], e += D;
            const b = i(c);
            y !== b && D > 0 && u(c, y, b, !1, !0);
          }
          a(r);
        }
        return e;
      }
      function B(n, e) {
        const r = t.get(n);
        if (!r) return;
        const c = r.modifiers.find((g) => g.source === e);
        if (c)
          return c.remainingDuration === 1 / 0 ? 1 / 0 : c.remainingDuration;
      }
      function J() {
        const n = [], e = l();
        for (const [r, c] of t.entries()) {
          const g = [], y = i(r);
          for (const D of c.modifiers)
            D.remainingDuration !== 1 / 0 && (D.remainingDuration--, D.remainingDuration <= 0 && (g.push(D.source), n.push(D.source)));
          if (g.length > 0) {
            c.modifiers = c.modifiers.filter((b) => !g.includes(b.source));
            const D = i(r);
            y !== D && u(r, y, D, !1, !0);
          }
        }
        return a(e), n;
      }
      function U(n) {
        return d === 0 ? [] : n === void 0 ? [...h] : h.slice(0, n);
      }
      function z() {
        h.length = 0;
      }
      function K(n) {
        return f.push(n), () => {
          const e = f.indexOf(n);
          e >= 0 && f.splice(e, 1);
        };
      }
      function X(n, e) {
        if (!t.get(n))
          throw new TypeError(`Cannot listen to non-existent stat: "${n}"`);
        return w.has(n) || w.set(n, []), w.get(n).push(e), () => {
          const c = w.get(n);
          if (c) {
            const g = c.indexOf(e);
            g >= 0 && c.splice(g, 1);
          }
        };
      }
      function W(n) {
        const e = t.get(n);
        return (e == null ? void 0 : e.isDerived) ?? !1;
      }
      function q() {
        const n = {}, e = {};
        for (const [r, c] of t.entries())
          c.isDerived || (n[r] = c.base, c.modifiers.length > 0 && (e[r] = c.modifiers.map((g) => ({
            value: g.value,
            source: g.source,
            type: g.type,
            duration: g.remainingDuration === 1 / 0 ? "permanent" : g.remainingDuration
          }))));
        return {
          version: 1,
          stats: n,
          modifiers: e
        };
      }
      function G(n, e) {
        t.set(n, {
          base: 0,
          modifiers: [],
          isDerived: !0,
          derivedFormula: e
        });
      }
      const T = {
        get: v,
        getBase: x,
        set: M,
        modify: C,
        has: I,
        stats: $,
        addModifier: O,
        removeModifier: P,
        getModifiers: j,
        clearModifiers: H,
        getRemainingDuration: B,
        tick: J,
        getRollHistory: U,
        clearRollHistory: z,
        onChange: K,
        onStat: X,
        isDerived: W,
        toJSON: q
      };
      return T._addDerivedStat = G, T._modifierFormula = p, T;
    }
    function oe(o, s, t) {
      const h = o.get(s);
      if (h === void 0)
        throw new TypeError(`Cannot check non-existent stat: "${s}"`);
      let f;
      if (t.modifier !== void 0)
        f = t.modifier;
      else {
        const a = o._modifierFormula;
        a ? f = a(h) : f = Math.floor((h - 10) / 2);
      }
      const w = t.bonus ?? 0, d = t.dice ?? "1d20";
      let p, m;
      if (t.advantage && t.disadvantage) {
        const a = S(d);
        p = a.rolls, m = a.total - a.modifier;
      } else if (t.advantage) {
        const a = S(d), v = S(d), x = a.total - a.modifier, M = v.total - v.modifier;
        p = [x, M], m = Math.max(x, M);
      } else if (t.disadvantage) {
        const a = S(d), v = S(d), x = a.total - a.modifier, M = v.total - v.modifier;
        p = [x, M], m = Math.min(x, M);
      } else {
        const a = S(d);
        p = a.rolls, m = a.total - a.modifier;
      }
      const i = m + f + w, u = i >= t.difficulty, l = i - t.difficulty;
      return {
        success: u,
        roll: m,
        rolls: p,
        modifier: f,
        bonus: w,
        total: i,
        difficulty: t.difficulty,
        margin: l
      };
    }
    function ie(o, s, t) {
      const h = o;
      h._derivedDependencies || (h._derivedDependencies = /* @__PURE__ */ new Map());
      const f = /* @__PURE__ */ new Set(), w = [], d = (m, i = /* @__PURE__ */ new Set()) => {
        if (i.has(m))
          return /* @__PURE__ */ new Set();
        i.add(m);
        const u = h._derivedDependencies.get(m);
        if (!u)
          return /* @__PURE__ */ new Set();
        const l = new Set(u);
        for (const a of u) {
          const v = d(a, i);
          for (const x of v)
            l.add(x);
        }
        return l;
      }, p = new Proxy(o, {
        get(m, i) {
          return i === "get" ? (u) => {
            if (u === s)
              throw w.push(s), new _("Circular dependency detected in derived stat", w);
            f.add(u);
            const l = d(u);
            if (l.has(s))
              throw w.push(u, ...Array.from(l), s), new _("Circular dependency detected in derived stat", w);
            return m.get(u);
          } : m[i];
        }
      });
      try {
        t(p);
      } catch (m) {
        if (m instanceof _)
          throw m;
      }
      return h._derivedDependencies.set(s, f), h._addDerivedStat && h._addDerivedStat(s, t), {
        getValue: () => {
          try {
            return t(o);
          } catch (m) {
            return console.error(`Error calculating derived stat "${s}":`, m), 0;
          }
        }
      };
    }
    function se(o, s, t) {
      return oe(o, s, { difficulty: t }).success;
    }
    function ce(o, s, t, h, f) {
      const w = (f == null ? void 0 : f.dice) ?? "1d20";
      let d, p;
      if (typeof o == "number" && typeof s == "number")
        d = o, p = s;
      else if (typeof o == "object" && typeof s == "string" && t && typeof h == "string") {
        const C = o.get(s), I = t.get(h);
        if (C === void 0)
          throw new TypeError(`Cannot contest with non-existent stat: "${s}"`);
        if (I === void 0)
          throw new TypeError(`Cannot contest with non-existent stat: "${h}"`);
        const $ = o._modifierFormula, O = t._modifierFormula;
        d = $ ? $(C) : Math.floor((C - 10) / 2), p = O ? O(I) : Math.floor((I - 10) / 2);
      } else
        throw new TypeError("Invalid contest arguments");
      const m = S(w), i = S(w), u = m.total - m.modifier, l = i.total - i.modifier, a = u + d, v = l + p;
      let x;
      a > v ? x = "a" : v > a ? x = "b" : x = "tie";
      const M = Math.abs(a - v);
      return {
        winner: x,
        rolls: { a: u, b: l },
        totals: { a, b: v },
        margin: M
      };
    }
    function le(o) {
      if (o.length === 0)
        throw new k("Roll table cannot be empty");
      for (const f of o)
        if (f.weight < 0)
          throw new k("Roll table weights cannot be negative");
      const s = o.reduce((f, w) => f + w.weight, 0);
      if (s === 0)
        throw new k("Roll table must have at least one non-zero weight");
      const t = Math.random() * s;
      let h = 0;
      for (const f of o)
        if (h += f.weight, t < h)
          return f.value;
      return o[o.length - 1].value;
    }
    function ae(o) {
      const { stats: s, options: t } = o;
      function h(f) {
        const w = {};
        for (const [d, p] of Object.entries(s)) {
          let m = p.default;
          f && d in f && (m = f[d]);
          const i = { base: m };
          p.min !== void 0 && (i.min = p.min), p.max !== void 0 && (i.max = p.max), w[d] = i;
        }
        if (f)
          for (const d of Object.keys(f))
            d in s || console.warn(`Override for unknown stat: ${d}`);
        return re(w, t);
      }
      return {
        create: h
      };
    }

    // Expose exports to window for demo use
    window.roll = S;
    window.createStatBlock = re;
    window.check = oe;
    window.createDerivedStat = ie;
    window.saveThrow = se;
    window.contest = ce;
    window.rollTable = le;
    window.createStatTemplate = ae;
    window.ParseError = V;
    window.ValidationError = k;
    window.CircularDependencyError = _;
    window.VersionError = Y;
  </script>

  <!-- ============================================ -->
  <!-- DEMO AND TEST CODE                           -->
  <!-- ============================================ -->
  <script>
    // Global state for interactive demos
    let currentCharacter = null;
    let derivedStatDemo = null;

    // ============================================
    // AUTOMATED TEST SUITE
    // ============================================
    const tests = [
      // Dice Rolling Tests
      {
        name: 'roll("1d6") returns value between 1-6',
        fn: async () => {
          const result = window.roll('1d6');
          if (result.total < 1 || result.total > 6) throw new Error(`Got ${result.total}, expected 1-6`);
        }
      },
      {
        name: 'roll("2d6+3") adds modifier correctly',
        fn: async () => {
          const result = window.roll('2d6+3');
          if (result.modifier !== 3) throw new Error(`Expected modifier 3, got ${result.modifier}`);
          if (result.total < 5 || result.total > 15) throw new Error(`Total out of range: ${result.total}`);
        }
      },
      {
        name: 'roll("4d6kh3") keeps highest 3 dice',
        fn: async () => {
          const result = window.roll('4d6kh3');
          if (result.rolls.length !== 4) throw new Error(`Expected 4 rolls, got ${result.rolls.length}`);
          if (result.kept.length !== 3) throw new Error(`Expected 3 kept, got ${result.kept.length}`);
        }
      },
      {
        name: 'roll("2d20kl1") keeps lowest 1 (disadvantage)',
        fn: async () => {
          const result = window.roll('2d20kl1');
          if (result.kept.length !== 1) throw new Error(`Expected 1 kept, got ${result.kept.length}`);
        }
      },
      {
        name: 'roll with invalid notation throws ParseError',
        fn: async () => {
          try {
            window.roll('invalid');
            throw new Error('Should have thrown ParseError');
          } catch (e) {
            if (e.name !== 'ParseError') throw new Error(`Expected ParseError, got ${e.name}`);
          }
        }
      },

      // Stat Block Tests
      {
        name: 'createStatBlock creates block with base values',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 14 } });
          const val = stats.get('strength');
          if (val !== 14) throw new Error(`Expected 14, got ${val}`);
        }
      },
      {
        name: 'set() changes stat value within bounds',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10, min: 1, max: 20 } });
          stats.set('strength', 16);
          if (stats.get('strength') !== 16) throw new Error('Set failed');
        }
      },
      {
        name: 'set() clamps to max bound',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10, max: 20 } });
          stats.set('strength', 25);
          if (stats.get('strength') !== 20) throw new Error('Max clamp failed');
        }
      },
      {
        name: 'modify() adjusts stat by delta',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.modify('strength', 5);
          if (stats.get('strength') !== 15) throw new Error('Modify failed');
        }
      },
      {
        name: 'addModifier() with flat type adds to value',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.addModifier('strength', { value: 2, source: 'buff', type: 'flat' });
          if (stats.get('strength') !== 12) throw new Error('Modifier not applied');
        }
      },
      {
        name: 'addModifier() with multiply type multiplies value',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.addModifier('strength', { value: 2, source: 'buff', type: 'multiply' });
          if (stats.get('strength') !== 20) throw new Error('Multiply modifier failed');
        }
      },
      {
        name: 'flat modifiers apply before multiply',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.addModifier('strength', { value: 2, source: 'flat', type: 'flat' });
          stats.addModifier('strength', { value: 2, source: 'mult', type: 'multiply' });
          // (10 + 2) * 2 = 24
          if (stats.get('strength') !== 24) throw new Error(`Expected 24, got ${stats.get('strength')}`);
        }
      },
      {
        name: 'removeModifier() removes by source',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.addModifier('strength', { value: 2, source: 'buff' });
          stats.removeModifier('strength', 'buff');
          if (stats.get('strength') !== 10) throw new Error('Remove failed');
        }
      },
      {
        name: 'temporary duration expires after 1 tick',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          stats.addModifier('strength', { value: 2, source: 'temp', duration: 'temporary' });
          if (stats.get('strength') !== 12) throw new Error('Modifier not applied');
          stats.tick();
          if (stats.get('strength') !== 10) throw new Error('Temporary modifier did not expire');
        }
      },
      {
        name: 'onChange fires when stat changes',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          let fired = false;
          stats.onChange((e) => { fired = true; });
          stats.set('strength', 12);
          if (!fired) throw new Error('onChange did not fire');
        }
      },

      // Check Tests
      {
        name: 'check() performs basic stat check',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 14 } });
          const result = window.check(stats, 'strength', { difficulty: 10 });
          if (typeof result.success !== 'boolean') throw new Error('Invalid result');
          if (typeof result.total !== 'number') throw new Error('Missing total');
        }
      },
      {
        name: 'check() calculates modifier correctly',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 14 } });
          const result = window.check(stats, 'strength', { difficulty: 10 });
          // (14-10)/2 = 2
          if (result.modifier !== 2) throw new Error(`Expected modifier 2, got ${result.modifier}`);
        }
      },
      {
        name: 'check() with advantage rolls twice',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 10 } });
          const result = window.check(stats, 'strength', { difficulty: 10, advantage: true });
          if (result.rolls.length !== 2) throw new Error(`Expected 2 rolls, got ${result.rolls.length}`);
        }
      },
      {
        name: 'saveThrow() returns boolean',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 14 } });
          const result = window.saveThrow(stats, 'strength', 10);
          if (typeof result !== 'boolean') throw new Error('Should return boolean');
        }
      },

      // Derived Stat Tests
      {
        name: 'createDerivedStat() creates computed stat',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 16 } });
          window.createDerivedStat(stats, 'carryCapacity', (s) => s.get('strength') * 10);
          if (stats.get('carryCapacity') !== 160) throw new Error('Derived stat failed');
        }
      },
      {
        name: 'derived stat updates when dependency changes',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 16 } });
          window.createDerivedStat(stats, 'carryCapacity', (s) => s.get('strength') * 10);
          stats.set('strength', 18);
          if (stats.get('carryCapacity') !== 180) throw new Error('Derived stat did not update');
        }
      },
      {
        name: 'circular dependency throws CircularDependencyError',
        fn: async () => {
          const stats = window.createStatBlock({ a: { base: 10 } });
          try {
            window.createDerivedStat(stats, 'b', (s) => s.get('b') + 1);
            throw new Error('Should have thrown CircularDependencyError');
          } catch (e) {
            if (e.name !== 'CircularDependencyError') throw new Error(`Expected CircularDependencyError, got ${e.name}`);
          }
        }
      },

      // Contest Tests
      {
        name: 'contest() between two stat blocks',
        fn: async () => {
          const hero = window.createStatBlock({ strength: { base: 16 } });
          const monster = window.createStatBlock({ strength: { base: 14 } });
          const result = window.contest(hero, 'strength', monster, 'strength');
          if (!['a', 'b', 'tie'].includes(result.winner)) throw new Error('Invalid winner');
        }
      },
      {
        name: 'contest() with raw modifiers',
        fn: async () => {
          const result = window.contest(5, 3);
          if (!result.winner) throw new Error('Missing winner');
        }
      },

      // Roll Table Tests
      {
        name: 'rollTable() selects from weighted entries',
        fn: async () => {
          const table = [
            { weight: 10, value: 'common' },
            { weight: 1, value: 'rare' }
          ];
          const result = window.rollTable(table);
          if (!['common', 'rare'].includes(result)) throw new Error('Invalid result');
        }
      },
      {
        name: 'rollTable() throws on empty table',
        fn: async () => {
          try {
            window.rollTable([]);
            throw new Error('Should have thrown ValidationError');
          } catch (e) {
            if (e.name !== 'ValidationError') throw new Error(`Expected ValidationError, got ${e.name}`);
          }
        }
      },

      // Template Tests
      {
        name: 'createStatTemplate() creates reusable template',
        fn: async () => {
          const template = window.createStatTemplate({
            stats: {
              strength: { default: 10, min: 1, max: 20 }
            }
          });
          const char1 = template.create({ strength: 16 });
          const char2 = template.create({ strength: 8 });
          if (char1.get('strength') !== 16) throw new Error('Template override failed');
          if (char2.get('strength') !== 8) throw new Error('Template override failed');
        }
      },

      // Serialization Tests
      {
        name: 'toJSON() serializes stat block',
        fn: async () => {
          const stats = window.createStatBlock({ strength: { base: 14 } });
          const json = stats.toJSON();
          if (json.version !== 1) throw new Error('Missing version');
          if (json.stats.strength !== 14) throw new Error('Stats not serialized');
        }
      },
      {
        name: 'fromJSON restores stat block',
        fn: async () => {
          const stats1 = window.createStatBlock({ strength: { base: 14 } });
          stats1.addModifier('strength', { value: 2, source: 'buff' });
          const json = stats1.toJSON();

          const stats2 = window.createStatBlock({ strength: { base: 10 } }, { fromJSON: json });
          if (stats2.get('strength') !== 16) throw new Error('Restore failed');
        }
      }
    ];

    // Test runner functions
    function logResult(name, status, error) {
      const output = document.getElementById('test-output');
      const className = status === 'PASS' ? 'test-pass' : 'test-fail';
      const errorMsg = error ? ` - ${error}` : '';
      const icon = status === 'PASS' ? '‚úì' : '‚úó';
      output.innerHTML += `<div class="${className}">${icon} ${name}${errorMsg}</div>`;
      output.scrollTop = output.scrollHeight;
    }

    function logSummary(passed, failed) {
      const summary = document.getElementById('summary');
      const total = passed + failed;
      const className = failed === 0 ? 'test-pass' : 'test-fail';
      const icon = failed === 0 ? '‚úÖ' : '‚ùå';
      summary.innerHTML = `<span class="${className}">${icon} ${passed}/${total} tests passed</span>`;
    }

    async function runAllTests() {
      clearResults();
      let passed = 0, failed = 0;
      const output = document.getElementById('test-output');
      output.innerHTML = '<div>Running tests...</div>';

      for (const test of tests) {
        try {
          await test.fn();
          logResult(test.name, 'PASS');
          passed++;
        } catch (e) {
          logResult(test.name, 'FAIL', e.message);
          failed++;
        }
      }
      logSummary(passed, failed);
    }

    function clearResults() {
      document.getElementById('test-output').innerHTML = '';
      document.getElementById('summary').innerHTML = '';
    }

    // ============================================
    // INTERACTIVE DEMO FUNCTIONS
    // ============================================

    // Dice Rolling Demo
    function rollDice() {
      const notation = document.getElementById('diceNotation').value;
      const output = document.getElementById('diceOutput');
      try {
        const result = window.roll(notation);
        output.innerHTML = `
<strong>Roll: ${notation}</strong>
Total: ${result.total}
Individual rolls: [${result.rolls.join(', ')}]
Kept dice: [${result.kept.join(', ')}]
Modifier: ${result.modifier > 0 ? '+' : ''}${result.modifier}
        `.trim();
      } catch (e) {
        output.innerHTML = `<span style="color: red;">Error: ${e.message}</span>`;
      }
    }

    function setExample(notation) {
      document.getElementById('diceNotation').value = notation;
    }

    // Stat Block Demo
    function createCharacter() {
      currentCharacter = window.createStatBlock({
        strength: { base: 16, min: 1, max: 20 },
        dexterity: { base: 14, min: 1, max: 20 },
        constitution: { base: 13, min: 1, max: 20 }
      });

      // Add event listener
      currentCharacter.onChange((event) => {
        const output = document.getElementById('statOutput');
        output.innerHTML += `\n[Event] ${event.stat}: ${event.oldValue} ‚Üí ${event.newValue}`;
      });

      updateStatDisplay();
    }

    function setStat() {
      if (!currentCharacter) {
        alert('Create a character first!');
        return;
      }
      const value = parseInt(document.getElementById('strValue').value);
      currentCharacter.set('strength', value);
      updateStatDisplay();
    }

    function addBuff() {
      if (!currentCharacter) {
        alert('Create a character first!');
        return;
      }
      currentCharacter.addModifier('strength', { value: 2, source: 'buff', type: 'flat' });
      updateStatDisplay();
    }

    function removeBuff() {
      if (!currentCharacter) {
        alert('Create a character first!');
        return;
      }
      currentCharacter.removeModifier('strength', 'buff');
      updateStatDisplay();
    }

    function updateStatDisplay() {
      const output = document.getElementById('statOutput');
      const str = currentCharacter.get('strength');
      const dex = currentCharacter.get('dexterity');
      const con = currentCharacter.get('constitution');
      const mods = currentCharacter.getModifiers('strength') || [];

      output.innerHTML = `
<strong>Character Stats</strong>
Strength: ${str} (base: ${currentCharacter.getBase('strength')})
Dexterity: ${dex}
Constitution: ${con}

Active modifiers on STR: ${mods.length}
${mods.map(m => `  - ${m.source}: ${m.value > 0 ? '+' : ''}${m.value} (${m.type})`).join('\n')}
      `.trim();
    }

    // Check Demo
    function performCheck() {
      if (!currentCharacter) {
        alert('Create a character first!');
        return;
      }

      const stat = document.getElementById('checkStat').value;
      const dc = parseInt(document.getElementById('checkDC').value);
      const mode = document.getElementById('checkMode').value;

      const options = { difficulty: dc };
      if (mode === 'advantage') options.advantage = true;
      if (mode === 'disadvantage') options.disadvantage = true;

      const result = window.check(currentCharacter, stat, options);
      const output = document.getElementById('checkOutput');

      output.innerHTML = `
<strong>${stat.toUpperCase()} Check (DC ${dc})</strong>
Result: ${result.success ? '‚úÖ SUCCESS' : '‚ùå FAILURE'}
Roll: ${result.roll}
${result.rolls.length > 1 ? `Rolls: [${result.rolls.join(', ')}]` : ''}
Modifier: ${result.modifier > 0 ? '+' : ''}${result.modifier}
Bonus: ${result.bonus > 0 ? '+' : ''}${result.bonus}
Total: ${result.total}
Margin: ${result.margin > 0 ? '+' : ''}${result.margin}
      `.trim();
    }

    // Derived Stat Demo
    function createDerivedDemo() {
      derivedStatDemo = window.createStatBlock({
        strength: { base: 16, min: 1, max: 20 },
        level: { base: 5, min: 1, max: 20 }
      });

      // Create derived stat: carryCapacity = strength * 10 + level * 5
      window.createDerivedStat(derivedStatDemo, 'carryCapacity', (stats) => {
        return stats.get('strength') * 10 + stats.get('level') * 5;
      });

      updateDerivedDisplay();
    }

    function updateDerived() {
      if (!derivedStatDemo) {
        alert('Create derived stat first!');
        return;
      }
      const str = parseInt(document.getElementById('derivedStr').value);
      derivedStatDemo.set('strength', str);
      updateDerivedDisplay();
    }

    function updateDerivedDisplay() {
      const output = document.getElementById('derivedOutput');
      const str = derivedStatDemo.get('strength');
      const lvl = derivedStatDemo.get('level');
      const carry = derivedStatDemo.get('carryCapacity');

      output.innerHTML = `
<strong>Derived Stat: Carry Capacity</strong>
Formula: strength √ó 10 + level √ó 5

Strength: ${str}
Level: ${lvl}
Carry Capacity: ${carry}

(${str} √ó 10 + ${lvl} √ó 5 = ${carry})
      `.trim();
    }
  </script>
</body>
</html>
